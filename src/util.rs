use color_eyre::Result;
use std::{fs::File, path::Path};
use tracing::debug;

#[macro_export]
macro_rules! cmd {
    (@ $cmd:ident [[$expr:expr]]) => { $cmd.args($expr); };
    (@ $cmd:ident $tt:tt) => { $cmd.arg(cmd!(# $tt)); };
    (# [$expr:literal $($arg:expr),*]) => { format!($expr, $($arg),*) };
    (# {{$expr:expr}}) => { format!("{}", $expr) };
    (# $expr:expr) => { &$expr };
    (# $expr:literal) => { $expr };

    (stdout $cmd:literal $($t:tt)+) => {{
        #[allow(unused_braces)]
        let cmd = cmd!($cmd $($t)+).output()?;
        String::from_utf8_lossy(&cmd.stdout).to_string()
    }};
    ($cmd:literal $($t:tt)*) => {{
        #[allow(unused_braces)]
        let mut cmd = std::process::Command::new($cmd);
        $(
            // #[allow(unused_braces)]
            cmd!(@ cmd $t);
        )*
        cmd
    }};
    ($cmd:block $($t:tt)*) => {{
        #[allow(unused_braces)]
        let mut cmd = std::process::Command::new(cmd!(# $cmd));
        $(
            // #[allow(unused_braces)]
            cmd!(@ cmd $t);
        )*
        cmd
    }};
    (?$cmd:tt $($t:tt)*) => {{
        use itertools::Itertools;
        #[allow(unused_braces)]
        let cmd_str = [Box::new($cmd) as Box<dyn std::fmt::Display>, $(Box::new(cmd!(# $t))),*].iter().join(" ");
        tracing::trace!("Running command: `{cmd_str}`");
        #[allow(unused_braces)]
        let status = cmd!($cmd $($t)*).status()?;
        if status.success() {
            Ok(())
        } else if let Some(rc) = status.code() {
            use color_eyre::Help;
            #[allow(unused_braces)]
			Err(color_eyre::Report::msg("Command exited")
				.warning(lazy_format::lazy_format!("Status code: {rc}"))
				.with_note(|| format!("Command: `{cmd_str}`"))
				.note("Status: {status}"))
		} else {
            use color_eyre::Help;
		    Err(color_eyre::Report::msg("Script terminated unexpectedly").note(lazy_format::lazy_format!("Status: {status}")))
		}
    }};
}

/// Macro for string feature flags.
/// Should return the value of the environment variable if defined, else None.
///
// todo: probably do some magic to let this be a cli flag
#[macro_export]
macro_rules! env_flag {
	($envar:literal) => {
		std::env::var($envar).ok()
	};
	($envar:ident) => {
		std::env::var(stringify!($envar)).unwrap_or($envar.to_owned())
	};
}

/// Macro that wraps around `cmd_lib::run_cmd`!, but runs it in a chroot
///
/// First argument is the chroot path, the following arguments are the command and arguments
///
/// Example:
/// ```rs
/// chroot_run!(PathBuf::from("/path/to/chroot"), "dnf", "install", "-y", "vim");
/// ```
///
/// Uses run! but `unshare -R` prepended with first argument
#[macro_export]
macro_rules! chroot_run {
	($chroot:expr, $n:expr $(, $arr:expr)* $(,)?) => {{
		chroot_run!($chroot, $n; [$($arr,)*])
	}};
	($chroot:expr, $n:expr; $arr:expr) => {{
		$crate::util::run_with_chroot(&std::path::PathBuf::from($chroot), || {
			$crate::run!($n; $arr)?;
			Ok(())
		})
	}};
	(~$chroot:expr, $n:expr $(, $arr:expr)* $(,)?) => {{
		chroot_run!(~$chroot, $n; [$($arr,)*])
	}};
	(~$chroot:expr, $n:expr; $arr:expr) => {{
		$crate::util::run_with_chroot(&std::path::PathBuf::from($chroot), || {
			$crate::run!(~$n; $arr)?;
			Ok(())
		})
	}};
}

/// Wraps around `cmd_lib::run_cmd`!, but mounts the chroot
/// Example:
///
/// ```rs
/// chroot_run!(PathBuf::from("/path/to/chroot"), chroot /path/to/chroot echo "hello world" > /hello.txt);
/// ```
#[macro_export]
macro_rules! chroot_run_cmd {
	($chroot:expr, $($cmd:tt)*) => {{
		$crate::util::run_with_chroot(&PathBuf::from($chroot), || {
			tracing::debug!("Running command: {}", stringify!($($cmd)*) );
			cmd_lib::run_cmd!($($cmd)*)?;
			Ok(())
		})
	}};
}

/// Runs in chroot, returns stdout
#[macro_export]
macro_rules! chroot_run_fun {
	($chroot:expr, $($cmd:tt)*) => {{
		$crate::util::run_with_chroot(&PathBuf::from($chroot), || {
			cmd_lib::run_fun!($($cmd)*)?;
			Ok(())
		})
	}};
}

/// Perform the let statement, else bail out with specified error message
#[macro_export]
macro_rules! bail_let {
	($left:pat = $right:expr => $err:expr) => {
		#[rustfmt::skip]
		let $left = $right else {
			return Err(color_eyre::eyre::eyre!($err));
		};
	};
}

/// Automatically generates prepend comments
#[macro_export]
macro_rules! prepend_comment {
	($var:ident: $path:literal, $desc:literal, $module:path) => {
		const $var: &str = concat!(
			"#\n# ",
			$path,
			": ",
			$desc,
			"\n# Automatically generated by Katsu Image Builder. See\n# ",
			stringify!($module),
			" for more information.\n\n"
		);
	};
}

/// Generates the file content using the template given
#[macro_export]
macro_rules! tpl {
	(@match $name:ident) => {
		$name
	};
	(@match $name:ident: $var:expr) => {
		($var)
	};
	($tmpl:expr => {$($name:ident$(: $var:expr)?),*} $(=>$out:expr)?) => {{
		tracing::debug!(tmpl=?$tmpl, "Generating file from template");
		let mut tera = tera::Tera::default();
		let mut ctx = tera::Context::new();
		$(
			ctx.insert(stringify!($name), &$crate::tpl!(@match $name$(: $var)?));
		)*
		let out = tera.render_str(include_str!($tmpl), &ctx)?;
		tracing::trace!(out, path = $tmpl, "tpl!() Template output");
		$(
			tracing::debug!(tmpl=?$tmpl, outfile=?$out, "Writing template output to file");
			$crate::util::just_write($out, &out)?;
		)?
		out
	}};
}

#[macro_export]
macro_rules! gen_phase {
	($skip_phases: ident) => {
		macro_rules! phase {
			($key:literal: $run:expr) => {
				if !$skip_phases.contains($key) {
					tracing::info_span!(concat!("phase$", $key)).in_scope(
						|| -> color_eyre::Result<()> {
							tracing::info!("Starting phase `{}`", $key);
							$run?;
							tracing::info!("Finished phase `{}`", $key);
							Ok(())
						},
					)?;
				} else {
					tracing::info!("Skipping phase `{}`", $key);
				}
			};
		}
	};
}

#[tracing::instrument]
pub fn exec(cmd: &str, args: &[&str], pipe: bool) -> color_eyre::Result<Vec<u8>> {
	tracing::debug!("Executing command");
	let out = std::process::Command::new(cmd)
		.args(args)
		.stdout(if pipe { std::process::Stdio::piped() } else { std::process::Stdio::inherit() })
		.stderr(if pipe { std::process::Stdio::piped() } else { std::process::Stdio::inherit() })
		.output()?;
	if out.status.success() {
		return if pipe {
			let stdout = String::from_utf8_lossy(&out.stdout);
			let stderr = String::from_utf8_lossy(&out.stderr);
			tracing::trace!(?stdout, ?stderr, "Command succeeded");
			Ok(out.stdout)
		} else {
			tracing::trace!("Command succeeded");
			Ok(vec![])
		};
	}
	use color_eyre::{eyre::eyre, Help, SectionExt};
	if pipe {
		let stdout = String::from_utf8_lossy(&out.stdout);
		let stderr = String::from_utf8_lossy(&out.stderr);
		Err(eyre!("Command returned code: {}", out.status.code().unwrap_or_default()))
			.with_section(move || stdout.trim().to_string().header("Stdout:"))
			.with_section(move || stderr.trim().to_string().header("Stderr:"))
	} else {
		Err(eyre!("Command returned code: {}", out.status.code().unwrap_or_default()))
	}
}

/// Create an empty sparse file with given size
pub fn create_sparse(path: &Path, size: u64) -> Result<File> {
	use std::io::{Seek, SeekFrom, Write};
	debug!(?path, size, "Creating sparse file");
	let mut f = File::create(path)?;
	// We seek to size - 1, since we write a null byte at the end
	f.seek(SeekFrom::Start(size - 1))?;
	f.write_all(&[0])?;
	Ok(f)
}

pub struct LoopDevHdl(loopdev::LoopDevice);

impl Drop for LoopDevHdl {
	fn drop(&mut self) {
		let Err(e) = self.0.detach() else { return };
		tracing::warn!("Fail to detach loopdev: {e:#}");
	}
}

#[tracing::instrument]
pub fn loopdev_with_file(path: &Path) -> Result<(std::path::PathBuf, LoopDevHdl)> {
	let lc = loopdev::LoopControl::open()?;
	let loopdev = lc.next_free()?;
	loopdev.attach_file(path)?;
	crate::bail_let!(Some(ldp) = loopdev.path() => "Fail to unwrap loopdev.path() = None");
	Ok((ldp, LoopDevHdl(loopdev)))
}

pub fn just_write(path: impl AsRef<Path>, content: impl AsRef<str>) -> Result<()> {
	use std::io::Write;
	let (path, content) = (path.as_ref(), content.as_ref());
	tracing::trace!(?path, content, "Writing content to file");
	crate::bail_let!(Some(parent) = path.parent() => "Invalid file path");
	let _ = std::fs::create_dir_all(parent);
	File::create(path)?.write_all(content.as_bytes())?;
	Ok(())
}
